[回到首页](../README.md)

# 1. 必会的算法问题

常考的算法问题，应该周期性的拿出来做，以加深理解。

[TOC]

## 1.1. 十大经典排序算法

### 1.1.1. 选择排序

在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；
第二次遍历n-2个数，找到最小的数值与第二个元素交换；
...
第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。

时间复杂度：O(n^2)
空间复杂度：O(1)
稳定性：不稳定

### 1.1.2. 插入排序

在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。

时间复杂度：O(n^2)
空间复杂度：O(1)
稳定性：稳定

### 1.1.3. 冒泡排序

两个数比较大小，较大的数下沉，较小的数冒起来。

时间复杂度：O(n^2)
空间复杂度：O(1)
稳定性：稳定

### 1.1.4. 快速排序

先从数列中取出一个数作为key值；
将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；
对左右两个小数列重复第二步，直至各区间只有1个数。

时间复杂度：平均O(N*log2N)
空间复杂度：O(N*log2N)
稳定性：不稳定

### 1.1.5. 希尔排序

在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。
然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。

时间复杂度：平均O(n^1.3)，最差O(n^2)，最好O(n)
空间复杂度：O(1)
稳定性：不稳定

### 1.1.6. 归并排序

先将序列拆分成两个子序列，然后对子序列分别进行排序，再合并。
从比较2个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。

时间复杂度：O(N*log2N)
空间复杂度：O(n)
稳定性：稳定

### 1.1.7. 计数排序

当前元素和更小的元素出现的次数和，即是最终有序序列里的位置
计数排序要求输入的数据必须是有确定范围的整数

时间复杂度：O(k+N)，k为数字位数
空间复杂度：O(k+N)
稳定性：稳定

### 1.1.8. 基数排序

将整数按位数切割成不同的数字，然后按每个位数分别比较
可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

时间复杂度：O(k*N)，k为数字位数
空间复杂度：O(k+N)
稳定性：稳定

### 1.1.9. 桶排序

假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）
计数排序的升级版，支持浮点数

时间复杂度：O(k+N)，k为数字位数
空间复杂度：O(k+N)
稳定性：稳定

### 1.1.10. 堆排序

升序-》大根堆、降序-》小根堆
将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

时间复杂度：平均O(N*log2N)
空间复杂度：O(1)
稳定性：不稳定

## 1.2. 经典查找算法

### 1.2.1. 顺序查找

时间复杂度：O(N)

空间复杂度：1

### 1.2.2. 二分查找

前提：有序

时间复杂度：O(logN)

空间复杂度：1

## 1.3. 动态规划类问题

三要素：

1、重叠子问题：使用备忘录来优化穷举过程

2、最优子结构：子问题最优解

3、状态转移方程



递归算法的时间复杂度：子问题的个数 x 解决一个子问题需要的时间

动态规划可以是自顶向下的递归算法，也可以是自底向上的迭代算法



斐波那契数列的状态转移方程：
$$
\begin{equation}
f(n)=
\left\{
     \begin{array}{lr}
     1, n=1,2 &  \\
     f(n-1)+f(n-2), n>2 &  
     \end{array}
\right.
\end{equation}
$$

### 1.3.1. 凑硬币 -- 最少硬币数

[题322](https://leetcode.cn/problems/coin-change/description/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

### 1.3.2. 凑硬币 -- 有多少种组合

[题518](https://leetcode.cn/problems/coin-change-ii/description/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

### 1.3.3. 斐波那契数列

[题509](https://leetcode.cn/problems/fibonacci-number/description/)

求第n项的值。

### 1.3.4. 背包问题

## 1.4. 回溯算法

算法框架：

```python
result = []
def backtrack(路径，选择列表):
    if 满足结束条件：
    	result.add(路径)
        return
    
    for 选择 in 选择列表：
    	if 不满足条件：
        	continue
            
    	做选择
        backtrack(新路径，新选择列表)
        撤销选择
```



### 1.4.1. 全排列问题

[题46](https://leetcode.cn/problems/permutations/description/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。

### 1.4.2. N皇后问题

[题51](https://leetcode.cn/problems/n-queens/description/)

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

### 1.4.3. 括号生成

[题22](https://leetcode.cn/problems/generate-parentheses/description/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

## 1.5. 双指针常用算法

### 1.5.1. 快慢指针

[题19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

寻找无环单链表的中点

### 1.5.2. 左右指针

[题1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

## 1.6. 二分搜索算法

## 1.7. 滑动窗口算法

### 1.7.1. 最长回文子串

[题5](https://leetcode.cn/problems/longest-palindromic-substring/description/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

### 1.7.2. 最长无重复子串

[题3](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

## 1.8. 回溯算法

## 1.9. BFS广度优先算法

### 1.9.1. 二叉树的最小高度

[题111](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

### 1.9.2. 解开密码的最少次数

[题752](https://leetcode.cn/problems/open-the-lock/description/)





# 2. 经典数据结构

## 2.1. 单链表

## 2.2. 哈希表

## 2.3. 栈和队列

## 2.4. 队列

## 2.5. 字符串

## 2.6. 树

## 2.7. 数组实现的堆

## 2.8. 查找

哈希表

跳跃表：可以实现二分查找的有序链表。利用空间换时间，增加了多级索引，跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树相近，但实现相对简单

B树、B+树

红黑树



# 3. 其他基础

## 3.1. 整数最值

```go
const INT_MAX = int(^uint32(0) >> 1)
const INT_MIN = ^INT_MAX

INT_MAX == math.MaxInt32, INT_MIN == math.MinInt32
```

## 3.2. 位移技巧

```go
n << 1 // n+n
n >> 1 // n/2
```

## 3.3. byte转整型

```go
// byte底层是uint8，表示0-255
int('9'-'0') // 9
byte(9+'0') // '9'
```

