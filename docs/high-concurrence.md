[回到首页](../README.md)

# 1. 高并发、高可用

说明

[TOC]

## 1.1. 分布式事务
XA是一个协议，是X/Open组织制定的关于分布式事务的一组标准接口，实现这些接口，便意味支持XA协议。
### 1.1.1. 二阶段提交
二阶段提交（2PC）是XA分布式事务协议的一种实现。其实在XA协议定义的函数中，通过xa_prepare,xa_commit已经能发现XA完整提交分准备和提交两个阶段。
### 1.1.2. TCC
TCC本质上是一个业务层面上的2PC，他要求业务在使用TCC模式时必须实现三个接口Try()、Confirm()和Cancel()

> 参考：[分布式事务-2PC与TCC](https://juejin.cn/post/7017333689109446670)

## 1.2. 死锁

### 1.2.1. 产生的四个必要条件

互斥：一个资源每次只能被一个进程使用(资源独立)。

请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放(不释放锁)。

不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺(抢夺资源)。

循环等待：若干进程之间形成一种头尾相接的循环等待的资源关闭(死循环)。

### 1.2.2. 如何避免死锁

1. 破坏”互斥”条件：系统里取消互斥、若资源一般不被一个进程独占使用，那么死锁是肯定不会发生的，但一般“互斥”条件是无法破坏的,因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。

2. 破坏“请求和保持”条件：

方法1：所有的进程在开始运行之前，必须一次性的申请其在整个运行过程各种所需要的全部资源。

优点：简单易实施且安全。

缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。

方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到，已经使用完毕的资源，然后再去请求新的资源。这样的话资源的利用率会得到提高，也会减少进程的饥饿问题。

3. 破坏“不剥夺”条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂的释放或者说被抢占了。

4. 破坏“循环等待”条件：可以通过定义资源类型的线性顺序来预防，可以将每个资源编号，当一个进程占有编号为i 的资源时，那么它下一次申请资源只能申请编号大于i 的资源。

## 1.3. CAP理论

CAP定理指出，分布式系统不能同时具有以下三个属性：

- 一致性（consistency）
- 可用性（availability）
- 分区容错性（partition resiliency）

在实践中，你可以选择要使用CP系统还是AP系统。

CP系统（具有一致性和分区容错性）始终是一致的，并且如果组件之间发生网络分区，则CP系统不会提供查询或进行更改，仅在系统完全连接后才能运行。显然，这意味着你牺牲了可用性。

AP系统（具有可用性和分区容错性）始终可用，并且可以以脑裂方式（split-brain）运行。当系统发生网络分区时，每个部分可以继续正常运行，但是系统会变得不一致，因为每个部分都不知道其他部分正在发生的事务。
AP系统通常被称为最终一致的系统，因为当恢复连接时，某些协调过程可确保整个系统再次同步。
