[回到首页](../README.md)

# 1. 高并发、高可用

说明

[TOC]

## 1.1. 分布式事务

XA是一个协议，是X/Open组织制定的关于分布式事务的一组标准接口，实现这些接口，便意味支持XA协议。

### 1.1.1. 二阶段提交/XA

二阶段提交（2PC）是XA分布式事务协议的一种实现。其实在XA协议定义的函数中，通过xa_prepare,xa_commit已经能发现XA完整提交分准备和提交两个阶段。

### 1.1.2. TCC

TCC本质上是一个业务层面上的2PC，他要求业务在使用TCC模式时必须实现三个接口Try()、Confirm()和Cancel()

### 1.1.3. SAGA

Saga是这一篇数据库论文sagas提到的一个方案。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

### 1.1.4. 本地消息表

写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。

### 1.1.5. 事务消息

阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题



> 参考：
>
> 1. [分布式事务-2PC与TCC](https://juejin.cn/post/7017333689109446670)
> 2. [分布式事务最经典的七种解决方案](https://segmentfault.com/a/1190000040321750)

## 1.2. 死锁

### 1.2.1. 产生的四个必要条件

互斥：一个资源每次只能被一个进程使用(资源独立)。

请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放(不释放锁)。

不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺(抢夺资源)。

循环等待：若干进程之间形成一种头尾相接的循环等待的资源关闭(死循环)。

### 1.2.2. 如何避免死锁

1. 破坏”互斥”条件：系统里取消互斥、若资源一般不被一个进程独占使用，那么死锁是肯定不会发生的，但一般“互斥”条件是无法破坏的,因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。

2. 破坏“请求和保持”条件：

方法1：所有的进程在开始运行之前，必须一次性的申请其在整个运行过程各种所需要的全部资源。

优点：简单易实施且安全。

缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。

方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到，已经使用完毕的资源，然后再去请求新的资源。这样的话资源的利用率会得到提高，也会减少进程的饥饿问题。

3. 破坏“不剥夺”条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂的释放或者说被抢占了。

4. 破坏“循环等待”条件：可以通过定义资源类型的线性顺序来预防，可以将每个资源编号，当一个进程占有编号为i 的资源时，那么它下一次申请资源只能申请编号大于i 的资源。



### 1.2.3. 锁的类型

在计算机科学中，常见的锁类型包括：

1. 互斥锁（Mutex）：互斥锁是一种最基本的锁类型，用于控制对共享资源的互斥访问。一次只能有一个线程持有互斥锁，其他线程必须等待锁被释放才能访问共享资源。
2. 读写锁（Read-Write Lock）：读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这样可以提高并发性能，适用于读多写少的场景。
3. 自旋锁（Spin Lock）：自旋锁是一种忙等待锁，线程在获取锁时不阻塞而是循环检查锁是否可用。适用于加锁时间短且线程数量较少的场景，避免线程切换的开销。
4. 条件变量（Condition Variable）：条件变量配合互斥锁使用，用于线程间的等待和通知。线程可以通过条件变量等待某个条件满足，其他线程在满足条件时通过条件变量通知等待的线程。
5. 读-写自旋锁（Read-Copy-Update Lock，RCU Lock）：RCU 锁主要用于读多写少且读操作频繁的场景。当写操作需要更新共享资源时，会等待所有正在读取的线程完成，然后进行更新。
6. 信号量（Semaphore）：信号量是一种计数器，用于控制同时访问共享资源的线程数量。线程在访问资源前会尝试获取信号量，如果计数器大于零则获取成功，否则需要等待其他线程释放资源。
7. 屏障（Barrier）：屏障用于控制线程在某个点上的同步，只有当所有线程都到达指定点时，屏障才会打开，线程才能继续执行。

## 1.3. CAP理论

CAP定理指出，分布式系统不能同时具有以下三个属性：

- 一致性（consistency）
- 可用性（availability）
- 分区容错性（partition resiliency）

在实践中，你可以选择要使用CP系统还是AP系统。

**CP系统**（具有一致性和分区容错性）始终是一致的，并且如果组件之间发生网络分区，则CP系统不会提供查询或进行更改，仅在系统完全连接后才能运行。显然，这意味着你牺牲了可用性。

**AP系统**（具有可用性和分区容错性）始终可用，并且可以以脑裂方式（split-brain）运行。当系统发生网络分区时，每个部分可以继续正常运行，但是系统会变得不一致，因为每个部分都不知道其他部分正在发生的事务。
AP系统通常被称为最终一致的系统，因为当恢复连接时，某些协调过程可确保整个系统再次同步。

## 1.4. Debezium

kafka confluent的一个插件，实现从MySQL binlog获取数据事件并发布到kafka消息队列，队列消费者订阅感兴趣的主题（数据表）

> 参考：
> 1. [数据同步工具之FlinkCDC/Canal/Debezium对比](https://www.cnblogs.com/importbigdata/articles/15658757.html)
> 2. [MySql实时数据变更事件捕获kafka confluent之debezium](https://juejin.cn/post/6844903662880309255)