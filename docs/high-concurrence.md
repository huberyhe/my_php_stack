[回到首页](../README.md)

# 1. 高并发、高可用

说明

[TOC]

## 1.1. 分布式事务

XA是一个协议，是X/Open组织制定的关于分布式事务的一组标准接口，实现这些接口，便意味支持XA协议。

### 1.1.1. 二阶段提交/XA

二阶段提交（2PC）是XA分布式事务协议的一种实现。其实在XA协议定义的函数中，通过xa_prepare,xa_commit已经能发现XA完整提交分准备和提交两个阶段。

### 1.1.2. TCC

TCC本质上是一个业务层面上的2PC，他要求业务在使用TCC模式时必须实现三个接口Try()、Confirm()和Cancel()

### 1.1.3. SAGA

Saga是这一篇数据库论文sagas提到的一个方案。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

### 1.1.4. 本地消息表

写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。

### 1.1.5. 事务消息

阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题



> 参考：
>
> 1. [分布式事务-2PC与TCC](https://juejin.cn/post/7017333689109446670)
> 2. [分布式事务最经典的七种解决方案](https://segmentfault.com/a/1190000040321750)

## 1.2. 死锁

### 1.2.1. 产生的四个必要条件

互斥：一个资源每次只能被一个进程使用(资源独立)。

请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放(不释放锁)。

不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺(抢夺资源)。

循环等待：若干进程之间形成一种头尾相接的循环等待的资源关闭(死循环)。

### 1.2.2. 如何避免死锁

1. 破坏”互斥”条件：系统里取消互斥、若资源一般不被一个进程独占使用，那么死锁是肯定不会发生的，但一般“互斥”条件是无法破坏的,因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。

2. 破坏“请求和保持”条件：

方法1：所有的进程在开始运行之前，必须一次性的申请其在整个运行过程各种所需要的全部资源。

优点：简单易实施且安全。

缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。

方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到，已经使用完毕的资源，然后再去请求新的资源。这样的话资源的利用率会得到提高，也会减少进程的饥饿问题。

3. 破坏“不剥夺”条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂的释放或者说被抢占了。

4. 破坏“循环等待”条件：可以通过定义资源类型的线性顺序来预防，可以将每个资源编号，当一个进程占有编号为i 的资源时，那么它下一次申请资源只能申请编号大于i 的资源。



### 1.2.3. 锁的类型

在计算机科学中，常见的锁类型包括：

1. 互斥锁（Mutex）：互斥锁是一种最基本的锁类型，用于控制对共享资源的互斥访问。一次只能有一个线程持有互斥锁，其他线程必须等待锁被释放才能访问共享资源。
2. 读写锁（Read-Write Lock）：读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这样可以提高并发性能，适用于读多写少的场景。
3. 自旋锁（Spin Lock）：自旋锁是一种忙等待锁，线程在获取锁时不阻塞而是循环检查锁是否可用。适用于加锁时间短且线程数量较少的场景，避免线程切换的开销。
4. 条件变量（Condition Variable）：条件变量配合互斥锁使用，用于线程间的等待和通知。线程可以通过条件变量等待某个条件满足，其他线程在满足条件时通过条件变量通知等待的线程。
5. 读-写自旋锁（Read-Copy-Update Lock，RCU Lock）：RCU 锁主要用于读多写少且读操作频繁的场景。当写操作需要更新共享资源时，会等待所有正在读取的线程完成，然后进行更新。
6. 信号量（Semaphore）：信号量是一种计数器，用于控制同时访问共享资源的线程数量。线程在访问资源前会尝试获取信号量，如果计数器大于零则获取成功，否则需要等待其他线程释放资源。
7. 屏障（Barrier）：屏障用于控制线程在某个点上的同步，只有当所有线程都到达指定点时，屏障才会打开，线程才能继续执行。

## 1.3. CAP理论

CAP定理指出，分布式系统不能同时具有以下三个属性：

- 一致性（consistency）
- 可用性（availability）
- 分区容错性（partition resiliency）

在实践中，你可以选择要使用CP系统还是AP系统。

**CP系统**（具有一致性和分区容错性）始终是一致的，并且如果组件之间发生网络分区，则CP系统不会提供查询或进行更改，仅在系统完全连接后才能运行。显然，这意味着你牺牲了可用性。

**AP系统**（具有可用性和分区容错性）始终可用，并且可以以脑裂方式（split-brain）运行。当系统发生网络分区时，每个部分可以继续正常运行，但是系统会变得不一致，因为每个部分都不知道其他部分正在发生的事务。
AP系统通常被称为最终一致的系统，因为当恢复连接时，某些协调过程可确保整个系统再次同步。

## 1.4. 分布式系统常见的一致性算法

### 1.4.1. Paxos算法

### 1.4.2. Raft协议

## 1.5. 负载均衡

### 1.5.1. 常见的负载均衡技术

1. 基于DNS的负载均衡
2. 反向代理负载均衡（如Nginx）
3. 基于NAT的负载均衡（如LVS）

### 1.5.2. 常见负载均衡算法

1. 轮询调度算法
2. 随机算法
3. 一致性哈希算法
4. 键值范围算法。优点：容易扩容；缺点：容易负载不均衡，新用户活跃度高



## 1.6. 分布式锁

mysql和redis能满足基本要求，但如果对锁的可靠性要求极高的话，只能使用etcd或者zookeeper这种通过一致性协议保证数据可靠性的方案。

### 1.6.1. 传统方案，利用持久化数据实现分布式锁

1、利用唯一索引实现分布式锁，加锁是创建记录，解锁是删除记录。

缺点（也有方法解决）：

- 强依赖数据库的可用性
- 锁没有过期时间，解锁失败后无法重新加锁
- 锁是非阻塞的
- 锁是非重入的，同一个线程不能再次获得该锁

2、利用数据库排他锁实现分布式锁，开启事务后`select ... for update`来获取锁，提交事务来解锁

### 1.6.2. 使用ZooKeeper实现分布式锁

### 1.6.3. 使用Redis的SETNX实现分布式锁

加锁与过期合并成一条指令；删除时使用lua脚本，只删除自己加的锁

```
SET lock_key random_value NX PX 10000
eval "if redis.call('get', KEY[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end 1" 1 lock_key random_value
```

### 1.6.4. 使用etcd实现分布式锁

1、利用租约在etcd集群中创建一个key

2、如果这个key不存在，则创建key，成功则获取到锁

3、如果该key已经存在，则不能创建key，获取锁失败

4、解除租约即释放锁

各种锁的概念：

1、共享锁、排他锁、互斥锁

2、乐观锁、悲观锁

## 1.7. 常见分布式应用

### 1.7.1. 用snowflake框架生成分布式ID

### 1.7.2. Paxos一致性算法

### 1.7.3. Debezium

kafka confluent的一个插件，实现从MySQL binlog获取数据事件并发布到kafka消息队列，队列消费者订阅感兴趣的主题（数据表）

> 参考：
> 1. [数据同步工具之FlinkCDC/Canal/Debezium对比](https://www.cnblogs.com/importbigdata/articles/15658757.html)
> 2. [MySql实时数据变更事件捕获kafka confluent之debezium](https://juejin.cn/post/6844903662880309255)

## 1.8. Go常见分布式框架

### 1.8.1. Go Micro框架

用于构建微服务的基础框架，提供了分布式开发所需的核心组件，包括RPC和时间驱动通信等。

### 1.8.2. Consul框架

包含多个组件作为基础设施并提供服务发现和服务配置的工具。

- 服务发现
- 健康检查
- Key/Value存储
- 多数据中心

## 1.9. 秒杀业务

### 1.9.1. 特点

1、定时开始

2、库存有限

3、操作可靠

### 1.9.2. 场景

1、预抢购业务

2、分批抢购

3、实时秒杀

### 1.9.3. 系统设计

#### 秒杀页面设计

1、页面优化：限制按钮单击数量，禁止重复请求；秒杀URL加密，避免提前泄露

2、秒杀页面静态化：使用CDN缓存静态资源

3、客户端限流：页面控制请求频率；

#### 服务端开发

1、代理层：缓存用户信息；过滤非法用户请求；限制请求频率（Nginx+Lua）

2、应用层：

2.1、防止超卖：

- 精简SQL：查询库存与减库存一起完成，`UPDATE seckill_product SET stock=stock-1 WHERE good_id=#{product_id} AND version=#{version} AND stock>0`
- Redis预减库存：注意使用分布式锁避免超卖问题

2.2、优化订单处理流程：写数据库时同时写缓存，用户从缓存中查询订单信息；为避免写数据库失败，需要有订单同步服务定时重试或更新缓存

2.3、大型高并发系统架构：

负载均衡：

- 代理式负载均衡：OSPF负载均衡、LVS、Nginx
- 平衡感知客户端负载均衡：负载均衡和服务发现能力被分散到每一个服务消费者的进程内部
- 外部负载均衡服务：同主机有一个独立的负载均衡进程做服务发现和负载均衡。也是分布式负载均衡方案，没有单点问题，且开发维护成本较低

2.4、秒杀抢购系统选型：先扣减库存，保证不超卖，然后异步生成订单（通过消息队列实现）；订单存在有效期，过期不支付则订单失效，进入新的库存

2.5、高并发下如何扣库存：本地减库存成功后，再去远程统一减库存；为避免机器宕机造成少买，本地库存有多余的数量

3、数据库层隔离：

3.1、 分库分表：MySQL单表推荐500w条记录

3.2、数据隔离：使用单独的表或库来存放秒杀相关的数据

3.3、数据合并：秒杀完成后，将隔离的数据合并到原有数据中



## 1.10. 指标

服务级指标（SLI）或关键性能指标（KPI）

平均无故障时间（MTBF）和平均恢复时间（MTTR）

响应时间：系统对请求做出响应的时间

吞吐量（QPS）：单位时间内处理的请求数量

每秒查询率：每秒响应请求数

并发用户数：同时承载正常系统功能的用户数量



# 云原生

## 链路追踪

## 云原生的关键组件

## 单体服务拆分成微服务的方法